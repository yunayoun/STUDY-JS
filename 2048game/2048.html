<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2048</title>
  <style>
    #table { border-collapse: collapse; user-select: none; }
    #table td {
      border: 10px solid #bbada0; width: 116px; height: 128px;
      font-size: 50px; font-weight: bold; text-align: center;
    }
    #score { user-select: none; }
    .color-2 { background-color: #eee4da; color: #776e65;}
    .color-4 { background-color: #eee1c9; color: #776e65;}
    .color-8 { background-color: #f3b27a; color: 'white';}
    .color-16 { background-color: #f69664; color: 'white';}
    .color-32 { background-color: #f77c5f; color: 'white';}
    .color-64 { background-color: #f75f3b; color: 'white';}
    .color-128 { background-color: #edd073; color: #776e65;}
    .color-256 { background-color: #edcc62; color: #776e65;}
    .color-512 { background-color: #edc950; color: #776e65;}
    .color-1024 { background-color: #edc53f; color: #776e65;}
    .color-2048 { background-color: #edc22e; color: #776e65;}
  </style>
</head>
<body>
  <div id="table"></div>
  <div>
    <span id="score">0</span>
    <button id="back">back</button>
  </div>


  <script>
    const $table = document.querySelector('#table');
    const $score = document.querySelector('#score');
    const $back = document.querySelector('#back');
    let data =[];
    let history= [];

    $back.addEventListener('click',()=>{
      const prevData =  history.pop();
      if(!prevData) return;//되돌리기 계속누르다가 없으면  종료
      $score.textContent = prevData.score;
      data = prevData.table;
      draw()
    })

    function startGame(){
      const $fragment = document.createDocumentFragment();
      [1,2,3,4].forEach(()=>{
        const rowData =[]
        data.push(rowData)
        const $tr = document.createElement('tr');
        [1,2,3,4].forEach(()=>{
          rowData.push(0)
          const $td = document.createElement('td');
          $tr.appendChild($td);
        })
        $fragment.appendChild($tr);
      })
      
      $table.appendChild($fragment);
      random2put()
      draw()
    }
    function random2put(){
      const emptyCells = [];//[[i1,j1],[i2,j2]]
      data.forEach((rowData,i)=>{
        rowData.forEach((cellData,j)=>{
          if(!cellData){//셀데이터의 0이므로 false,빈칸들의 위치를 엠티셀 모아둔다 
            emptyCells.push([i,j])
          }
        })
      })
      //randomCell = [i,j]
      const randomCell = emptyCells[Math.floor(Math.random()*emptyCells.length)]
      data[randomCell[0]][randomCell[1]] = 2;
    }
    function draw(){
      data.forEach((rowData,i)=>{
        rowData.forEach((cellData,j)=>{
          const $target = $table.children[i].children[j];
          if(cellData > 0){
            $target.textContent = cellData;
            $target.className = 'color-'+cellData;
          }else{//0이면
            $target.textContent ='';
            $target.className = '';

          }
        })
      })
    }
    
    startGame();

  //   data = [
  //   [0, 2, 4, 2],
  //   [0, 0, 8, 0],
  //   [2, 2 ,4, 8],
  //   [0, 16, 4, 4],
  // ];
  // draw();
    function moveCells(direction){
      history.push({
        table:JSON.parse(JSON.stringify(data)),//깊은복사
        score: $score.textContent,
      });

      switch(direction){
      case 'left':{//case문에선 {}잘안쓰지만 변수선언하면 해줌
        const newData = [[],[],[],[]];
        data.forEach((rowData,i)=>{
          rowData.forEach((cellData,j)=>{
            if(cellData){
              const currentRow = newData[i];
              //이전값은 현재값을 넣기전 항상 마지막값이된다
              const prevData = currentRow[currentRow.length -1];
              if(prevData === cellData){//이전값과현재값 같으면
                const score = parseInt($score.textContent);
                $score.textContent = score + currentRow[currentRow.length - 1] * 2;
                currentRow[currentRow.length-1]*= -2;
                // *2로 하면 2,2,4,8,경우 4,4,8 에서 안끝나고 한번에 계산되서 16나옴
                //*-2로 하면 -4가되고 그럼 4와 달라서 계산을 안함
              }else{
                newData[i].push(cellData);
              }
            }
          });
        });
        console.log(newData);
        [1,2,3,4].forEach((rowData,i)=>{
          [1,2,3,4].forEach((cellData,j)=>{
            data[i][j] =Math.abs(newData[i][j]) || 0;//-로 나오는 숫자를 절대값이로 정수로바꿈
          });
        });
        break;
      }
      case 'right': {
        const newData = [[], [], [], []];
        data.forEach((rowData, i) => {
          rowData.forEach((cellData, j) => {
            if (rowData[3 - j]) {
              const currentRow = newData[i]
              const prevData = currentRow[currentRow.length - 1];
              if (prevData === rowData[3 - j]) {
                const score = parseInt($score.textContent);
                $score.textContent = score + currentRow[currentRow.length - 1] * 2;
                currentRow[currentRow.length - 1] *= -2;
              } else {
                newData[i].push(rowData[3 - j]);
              }
            }
          });
        });
        console.log(newData);
        [1, 2, 3, 4].forEach((rowData, i) => {
          [1, 2, 3, 4].forEach((cellData, j) => {
            data[i][3 - j] = Math.abs(newData[i][j]) || 0;
          });
        });
        break;
      }
      case 'up': {
        const newData = [[], [], [], []];
        data.forEach((rowData, i) => {
          rowData.forEach((cellData, j) => {
            if (cellData) {
              const currentRow = newData[j]
              const prevData = currentRow[currentRow.length - 1];
              if (prevData === cellData) {
                const score = parseInt($score.textContent);
                $score.textContent = score + currentRow[currentRow.length - 1] * 2;
                currentRow[currentRow.length - 1] *= -2;
              } else {
                newData[j].push(cellData);
              }
            }
          });
        });
        console.log(newData);
        [1, 2, 3, 4].forEach((cellData, i) => {
          [1, 2, 3, 4].forEach((rowData, j) => {
            data[j][i] = Math.abs(newData[i][j]) || 0;
          });
        });
        break;
      }
      case 'down': {
        const newData = [[], [], [], []];
        data.forEach((rowData, i) => {
          rowData.forEach((cellData, j) => {
            if (data[3 - i][j]) {
              const currentRow = newData[j];
              const prevData = currentRow[currentRow.length - 1];
              if (prevData === data[3 - i][j]) {
                const score = parseInt($score.textContent);
                $score.textContent = score + currentRow[currentRow.length - 1] * 2;
                currentRow[currentRow.length - 1] *= -2;
              } else {
                newData[j].push(data[3 - i][j]);
              }
            }
          });
        });
        console.log(newData);
        [1, 2, 3, 4].forEach((cellData, i) => {
          [1, 2, 3, 4].forEach((rowData, j) => {
            data[3 - j][i] = Math.abs(newData[i][j]) || 0;
          });
        });
        break;
      }
    }
    if (data.flat().includes(2048)) { // 승리
      draw();
      setTimeout(() => {
        alert('축하합니다. 2048을 만들었습니다!');  
      }, 0);
    } else if (!data.flat().includes(0)) { // 빈 칸이 없으면 패배
      alert(`패배했습니다... ${$score.textContent}점`);
    } else {
      random2put();
      draw();
    }
  }
    window.addEventListener('keyup',(e)=>{
      if(e.key === 'ArrowUp'){
        moveCells('up');
      }else if(e.key === 'ArrowDown'){
        moveCells('down');
      }else if(e.key === 'ArrowLeft'){
        moveCells('left');
      }else if(e.key === 'ArrowRight'){
        moveCells('right');
      }
    });
    
    let startCoord;
    window.addEventListener('mousedown',(e)=>{
      startCoord = [e.clientX,e.clientY]
    });
    window.addEventListener('mouseup',(e)=>{
      let endCoord = [e.clientX,e.clientY];
      const diffX = endCoord[0]-startCoord[0];
      const diffY = endCoord[1]-startCoord[1];
      if(diffX < 0 && Math.abs(diffX)> Math.abs(diffY)){
        moveCells('left')
      }else if(diffX > 0 && Math.abs(diffX)> Math.abs(diffY)){
        moveCells('right')
      }else if(diffY > 0 && Math.abs(diffX) <= Math.abs(diffY)){
        moveCells('down')
      }else if(diffY < 0 && Math.abs(diffX) <= Math.abs(diffY)){
        moveCells('up')
      }
    })


  </script>
</body>
</html>